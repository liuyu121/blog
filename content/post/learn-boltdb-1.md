---
title: "Boltdb 源码学习 - 基础（一）"
date: 2020-09-02T11:04:39+08:00
lastmod: 2020-09-02T11:04:39+08:00
draft: false
categories: ["go"]
tags: ["go", "BoltDB", "Database"]
typora-root-url: ../../static
---

[boltDB](https://github.com/boltdb/bolt) 是用 `go` 写的一款基于本地内存的 `k-v 存储引擎`，`etcd` 底层就使用了 `boltDB`。相对于其他常见的如 `MySQL`、`redis` 等，实现的公功能较简单，所以可以通过阅读源码，加强对数据库、操作系统（特别是文件这一块）以及 `go` 语言本身的理解。

在阅读源码前，先要了解一些概念，比如操作系统（基于 `Linux`）的 `虚拟内存`、`MMU`、`TLB`、`page`、`mmap` 、`COW`、`B+ tree` 等。

## 基础概念

操作系统操作文件无非主要就是（通过 `cpu`、[DMA](https://en.wikipedia.org/wiki/Direct_memory_access)）：

* 从磁盘 `load` 数据到内存
* 从内存写入数据到磁盘

## 内存管理

首先，放一张经典图：

![](/img/MMU_principle_updated.png)

####  物理内存与虚拟内存

物理内存，也即我们常说的内存条，是  `cpu` 的地址线可以直接进行寻址的内存空间大小，常见的如 `512MB`、`4GB`、`	8GB`。也即，物理内存的大小，本质是 `min(内存条大小, cpu 总线可寻址大小)`。

从物理内存的定义即可知，其空间有限，所以不一定能满足实际中的需求，比如要读取一个大于物理内存的文件。另外，操作系统设计时，为了方便程序员编写程序，如果直接使用物理内存，多个程序可能会产生混用破坏，且所持有的空间大多是非连续的。

所以，操作系统就通过把一部分**硬盘空间**，当做一段连续的物理内存来使用，这就是所谓的**虚拟内存**，对于程序编写者来说，可以同视为一段连续的、私有的、独享的内存块。

#### 分页机制

上面提到物理内存与虚拟内存的关系，虚拟内存本质是把文件映射在物理内存中，那么操作系统是怎么管理这种映射呢？

首先，操作系统会把虚拟内存与物理内存分割成大小相同的区块（`page`），通过编号将进程的各个页离散地存储在内存中（注意：内存的地址可能不是连续的），然后以该区块大小为单位进行传输。

* `virtual page, VP`：将应用程序的逻辑地址空间分割并编号，可称之为 `page`。从进程的角度看来，它可认为自己持有一段连续的内存，进程实际运行时，可认为编号是总是从 `0` 开始的。

* `physical page, PP`：对应的，也会将内存地址空间分割并编号，可称之为 `frame`。

然后，操作系统有一个叫做页表（`page table`）的东西，本质是一个存放在物理内存中的数据结构，其中的元素成为页表项（`PTE：page table entry`），这些条目记录了 `page` 与 `frame` 的映射关系，形如 `<page-no, frame-no>`，且有如下标记位：

* `P`：存在（·Present·）标志，用于指明表项对地址转换是否有效。`P=1` 表示有效；`P=0` 表示无效。如果无效，则会产生缺页异常，通过中断的形式装载磁盘数据至内存。
	
* `R/W`：读/写（`Read/Write`）标志。其中，`1` 表示页面可以被读、写或执行，`0` 表示页面只读或可执行。

#### 转换流程

系统会为每一个进程建立一张页表，页表在内存中起始地址与页表长度，维护在 `process control block，PCB` 中），进程执行时，通过查找进程自己的页表，找到每页在内存中的物理块号。页表一般通过**硬件实现（页表寄存器, PTR）**，且常驻于内存。

大概转换流程流程如下：

* 1、进程访问某个逻辑地址（`page-no + 偏移量`），触发寻址操作。
* 2、将页表起始地址、页表长度读入页表寄存器（`PTR`），然后根据 `page-no`，以及起始地址，查询页表项`。
* 3、通过页表项上的映射找到  `frame-no`。
* 4、通过  `frame-no`，加上逻辑地址的页内地址，定位到具体的物理地址（ `frame-no + 偏移量`）。
* 5、进程访问该物理地址。

在转换流程中，会有地址保护机制，也即不能越界访问到非当前进程的地址，否则会发生段错误（`Segmentation fault`，`SIGSEGV` 信号被触发）。如果访问的页不在内存中，则会产生**缺页中断**，从磁盘装载数据至内存，并更新页表（按需调用）。

因为程序实际运行时，大多只需要极少的页表，所以现代操作系统常用的是**多级页表机制**，在单级页表上，通过增加多层级页号，如主页号、次页号等，实现按需加载。

由以上流程可知，整个过程需要访问两次内存：查找页表中的 `frame-no`，以及根据 `frame-no` 访问物理地址的数据；且多级页表需要访问多次页表数据。所以寻址的代价较大（内存速度远小于 `cpu` 的速度），解决方案是给 `CPU` 增加所谓  `TLB：Translation lookaside buffer` 的高速缓存，常称之为 **转址旁路缓存**，或称之为**快表**，用于缓存页表数据。有了 `TLB` 后，寻址流程就如下：

* 第 `2` 步从 `TLB` 中查找页表项，找到则为命中（`TLB hit`）：
	* 通过上述 `3~4` 流程，找到具体的物理地址。
	* 从 `CPU` 的 `L0\L1` 高速缓存中查找数据，没找到再从内存中查找。
* 如果 `TLB` 不存在该页号，则等同于上述 `2~5` 流程。

一般地，上述寻址过程，是由一个叫 `MMU`（`Memory Management Unit`，内存管理单元）的硬件来实现的。

`TLB` 机制较为复杂，可查看这篇文深入理解：[TLB原理](https://zhuanlan.zhihu.com/p/108425561)

#### page

上面提到的 `page`，常称为**内存页**，就是操作系统操作文件时的传输单位，也即操作系统都会整 `page` 大小的读取或写入，一般地，`page` 最常见的大小为 `4kb`。之所以按照 `page` 进行操作，是因为：

* `page` 过小，页表寻址时开销较大，效率较低。所谓余额表
* `page` 过大，可能会造成内存空间的浪费，导致内存碎片产生，且内存利用率较低。

所以，在当时的硬件架构体系下，远古大神们权衡后，默认大小设置为了 `4kb`。

## mmap

## COW 技术

## B+ tree


> 参考文献

* [虚拟内存的那点事儿](https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/)


